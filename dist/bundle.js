function t(t={...l},n){return"function"==typeof t?f.call(null,{...l,_context:"server"},t,n):f.bind(null,{...t,_context:"server"})}function n(t={...l},n){return"function"==typeof t?f.call(null,{...l,_context:"client"},t,n):f.bind(null,{...t,_context:"client"})}function e(t={...d},n){return"function"==typeof t?h.call(null,{...d},t,n):h.bind(null,t)}const o=async(t,n)=>await w(t),s=async(t,n)=>await w(t),r=async(t,n)=>await w(t),a=async(t,n)=>await w(t),i=async(t,n)=>await w(t),c=Symbol("ServellRPCExtension"),u=globalThis.ServellRPCExtension??=new Map,l={endpoint:"/api/rpc",_context:"server"},d={method:"GET"};function f(t,n,e){const{endpoint:o,_context:s}=t;if(!o)throw new Error("Missing 'endpoint' option in args to route the requests");const r=class extends n{constructor(...t){super(...t)}};e.addInitializer((()=>{const t=o+":"+e.name;u.has(t)||u.set(t,new Map);const r=u.get(t),c=n.prototype;for(const t of Reflect.ownKeys(c)){const n=c[t];if("function"==typeof n){if(c[t]=n.bind(c),!p(n))continue;if("client"==s){if(!y())continue;c[t]=a(t,c[t])}if("server"==s){if(y())continue;r.set(String(t),c[t]=i(c[t]))}}}}));for(const t of Reflect.ownKeys(n))t in r||(r[t]=n[t]);return r;function a(t,n){return async(...s)=>{const{method:r="GET",body:a,cache:i,headers:u}=n[c]??{},l="GET"!=r&&!0===a,d=new Headers(u);d.set("X-Servell-Function",e.name+"."+String(t)),d.set("X-Servell-Args",l?"body":JSON.stringify(s));const f=await fetch(o,{method:r,body:l?JSON.stringify(s):void 0,cache:i,headers:d});await n(...s,f)}}function i(t){return async(...n)=>{const e=t[c]?.content??"json";let o={status:"error"};try{const s=await t(...n);switch(e){case"json":o={status:"ok",data:s};break;case"text":o={status:"ok",data:String(s)};break;default:o={status:"ok",data:null}}}catch(t){o={status:"error",data:String(t)}}finally{return o}}}}function h(t,n,e){const{body:o,cache:s,content:r,headers:a,method:i}=t;e.addInitializer((()=>{n[c]={body:o,cache:s,content:r,headers:a,method:i}}))}const w=async(t,n)=>{const e=t.headers.get("X-Servell-Function"),o=t.headers.get("X-Servell-Args");if(!e||!o)throw new Error("Required headers 'X-Servell-Function' or 'X-Servell-Args' missing from the request");const[s,r]=e.split(".");if(!s||!r)throw new Error("The value of the 'X-Servell-Function' header is invalid");const a="body"==o?await t.json():JSON.parse(o),i=new URL(t.url).pathname,c=u.get(i+":"+s)?.get(r),l=`The rpc method '${s}.${r}' not found on path '${i}'`;if(!c)return Response.json({status:"error",data:l},{status:404});const d=await c(...a),f="ok"==d.status?200:500;return Response.json(d,{status:f})};function y(){return"undefined"!=typeof window&&window.document&&Object.is(globalThis,window)}function p(t){return t instanceof(async()=>{}).constructor}export{n as client,i as deleteHandler,o as getHandler,p as isAsyncFunction,y as isBrowser,e as params,a as patchHandler,s as postHandler,r as putHandler,t as server};
//# sourceMappingURL=bundle.js.map
